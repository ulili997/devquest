export const DSA_PART2 = [
  {
    id: 6, title: "Trees", icon: "\u{1F9EE}", color: "#E74C3C", desc: "Binary Trees & BST",
    lessons: [
      {
        title: "Binary Trees",
        slides: [
          { type: "teach", content: "A **binary tree** has nodes with at most two children (left and right). The topmost node is the **root**.", highlight: "binary tree" },
          { type: "teach", content: "Tree traversals visit nodes in different orders: **inorder** (left-root-right), **preorder** (root-left-right), **postorder** (left-right-root).", highlight: "inorder" },
        ],
        questions: [
          { q: "What is the maximum number of children a node can have in a binary tree?", options: ["1", "2", "3", "Unlimited"], answer: 1 , explanation: "2 follows from binary tree properties and traversal rules." },
          { q: "What is the topmost node of a tree called?", options: ["Leaf", "Parent", "Root", "Branch"], answer: 2 , explanation: "Root follows from binary tree properties and traversal rules." },
          { q: "A node with no children is called a:", options: ["Root", "Parent", "Subtree", "Leaf"], answer: 3 , explanation: "Leaf follows from binary tree properties and traversal rules." },
          { difficulty: "average", type: "output", q: "What does this code print?", code: "class Node {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\nconst root = new Node(1);\nroot.left = new Node(2);\nroot.right = new Node(3);\nconsole.log(root.left.val, root.right.val);", options: ["1 1", "2 3", "3 2", "null null"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the binary tree node class:", code: "class TreeNode {\n  constructor(val) {\n    this.val = ___BLANK1___;\n    this.left = ___BLANK2___;\n    this.right = null;\n  }\n}", blanks: [{ id: "BLANK1", options: ["null", "val", "undefined", "0"], answer: 1 }, { id: "BLANK2", options: ["val", "this", "null", "0"], answer: 2 }] , explanation: "val follows from binary tree properties and traversal rules." },
          { difficulty: "average", q: "What is the height of a tree with a single node (just the root)?", options: ["-1", "0", "1", "2"], answer: 1 , explanation: "0 follows from binary tree properties and traversal rules." },
          { difficulty: "advanced", type: "freeform", q: "Write a function that counts the total number of nodes in a binary tree using recursion.", starterCode: "function countNodes(root) {\n  // your code here\n}", patterns: ["countNodes\\(root\\.left\\)|countNodes\\(root\\.right\\)", "return.*1", "null|!root"], sampleAnswer: "function countNodes(root) {\n  if (!root) return 0;\n  return 1 + countNodes(root.left) + countNodes(root.right);\n}" },
          { difficulty: "advanced", type: "output", q: "What does this function return when called on a full binary tree with 7 nodes?", code: "function height(node) {\n  if (!node) return -1;\n  return 1 + Math.max(height(node.left), height(node.right));\n}\n// Tree:       1\n//           /   \\\n//          2     3\n//         / \\   / \\\n//        4   5 6   7\nconsole.log(height(root));", options: ["1", "2", "3", "7"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the steps to build a binary tree from an array [1, 2, 3, 4, 5]:", lines: ["Create root node with array[0]", "For node at index i, left child is at index 2*i + 1", "For node at index i, right child is at index 2*i + 2", "Recursively assign children until index exceeds array length", "Return the root node"], correctOrder: [0, 1, 2, 3, 4] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "BST Operations",
        slides: [
          { type: "teach", content: "A **Binary Search Tree (BST)** follows one rule: for every node, all values in the **left subtree are smaller** and all values in the **right subtree are larger**.", highlight: "Binary Search Tree" },
          { type: "teach", content: "BST operations (search, insert, delete) run in **O(log n)** on average because each step eliminates half the tree. A degenerate BST degrades to **O(n)**.", highlight: "O(log n)" },
        ],
        questions: [
          { q: "In a BST, where are values smaller than the root stored?", options: ["Right subtree", "Left subtree", "Parent node", "Leaf nodes only"], answer: 1 , explanation: "Left subtree follows from binary tree properties and traversal rules." },
          { q: "What is the average time complexity of searching in a BST?", options: ["O(n)", "O(n^2)", "O(log n)", "O(1)"], answer: 2 , explanation: "O(log n) describes how the algorithm scales with input size." },
          { q: "The smallest element in a BST is found by:", options: ["Going right until a leaf", "Going left until a leaf", "Checking the root", "Using BFS"], answer: 1 , explanation: "Going left until a leaf follows from binary tree properties and traversal rules." },
          { difficulty: "average", type: "output", q: "What does this BST insert produce? (print inorder)", code: "function insert(root, val) {\n  if (!root) return new Node(val);\n  if (val < root.val) root.left = insert(root.left, val);\n  else root.right = insert(root.right, val);\n  return root;\n}\nlet root = null;\n[5, 3, 7, 1, 4].forEach(v => root = insert(root, v));\n// Inorder traversal prints:", options: ["5 3 7 1 4", "1 3 4 5 7", "7 5 4 3 1", "5 3 1 4 7"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the BST search function:", code: "function search(root, target) {\n  if (!root) return ___BLANK1___;\n  if (target === root.val) return root;\n  if (target < root.val) return search(root.___BLANK2___, target);\n  return search(root.right, target);\n}", blanks: [{ id: "BLANK1", options: ["root", "null", "true", "false"], answer: 1 }, { id: "BLANK2", options: ["right", "left", "val", "parent"], answer: 1 }] , explanation: "null follows from binary tree properties and traversal rules." },
          { difficulty: "average", q: "When deleting a node with two children from a BST, you typically replace it with:", options: ["The root node", "The inorder successor (smallest in right subtree)", "The largest value in the tree", "null"], answer: 1 , explanation: "The inorder successor (smallest in right subtree) follows from binary tree properties and traversal rules." },
          { difficulty: "advanced", type: "freeform", q: "Write a function that validates whether a binary tree is a valid BST. A valid BST has all left descendants strictly less and all right descendants strictly greater.", starterCode: "function isValidBST(root) {\n  // your code here\n}", patterns: ["min|max|lower|upper|bound|-Infinity|Infinity", "left|right", "return.*true|return.*false"], sampleAnswer: "function isValidBST(root, min = -Infinity, max = Infinity) {\n  if (!root) return true;\n  if (root.val <= min || root.val >= max) return false;\n  return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\n}" },
          { difficulty: "advanced", type: "output", q: "What does this function return?", code: "function findKthSmallest(root, k) {\n  const stack = [];\n  let node = root;\n  let count = 0;\n  while (node || stack.length) {\n    while (node) { stack.push(node); node = node.left; }\n    node = stack.pop();\n    count++;\n    if (count === k) return node.val;\n    node = node.right;\n  }\n}\n// BST:    5\n//        / \\\n//       3   7\n//      / \\\n//     2   4\nconsole.log(findKthSmallest(root, 3));", options: ["2", "3", "4", "5"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the steps to delete a node with two children from a BST:", lines: ["Find the node to delete", "Find the inorder successor (smallest node in right subtree)", "Replace the node's value with the successor's value", "Delete the inorder successor from the right subtree", "Return the modified tree"], correctOrder: [0, 1, 2, 3, 4] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "Tree Traversals (BFS/DFS)",
        slides: [
          { type: "teach", content: "**DFS (Depth-First Search)** explores as deep as possible before backtracking. It comes in three flavors: **inorder**, **preorder**, and **postorder**.", highlight: "DFS" },
          { type: "teach", content: "**BFS (Breadth-First Search)** visits nodes level by level using a **queue**. It's ideal for finding the shortest path or level-order traversal.", highlight: "BFS" },
        ],
        questions: [
          { q: "BFS uses which data structure to keep track of nodes?", options: ["Stack", "Queue", "Linked list", "Hash map"], answer: 1 , explanation: "Queue follows from binary tree properties and traversal rules." },
          { q: "DFS explores a tree by going:", options: ["Level by level", "As deep as possible first", "Only left children", "Randomly"], answer: 1 , explanation: "As deep as possible first follows from binary tree properties and traversal rules." },
          { q: "Which traversal visits nodes in the order: left, root, right?", options: ["Preorder", "Postorder", "Inorder", "Level-order"], answer: 2 , explanation: "Inorder follows from binary tree properties and traversal rules." },
          { difficulty: "average", type: "output", q: "What does this BFS traversal print?", code: "function bfs(root) {\n  const queue = [root];\n  const result = [];\n  while (queue.length) {\n    const node = queue.shift();\n    result.push(node.val);\n    if (node.left) queue.push(node.left);\n    if (node.right) queue.push(node.right);\n  }\n  return result;\n}\n// Tree:    1\n//         / \\\n//        2   3\n//       / \\\n//      4   5\nconsole.log(bfs(root));", options: ["[1, 2, 4, 5, 3]", "[4, 2, 5, 1, 3]", "[1, 2, 3, 4, 5]", "[4, 5, 2, 3, 1]"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the preorder DFS traversal:", code: "function preorder(node, result = []) {\n  if (!node) return result;\n  result.push(___BLANK1___);\n  preorder(node.___BLANK2___, result);\n  preorder(node.right, result);\n  return result;\n}", blanks: [{ id: "BLANK1", options: ["node.left", "node.right", "node.val", "node"], answer: 2 }, { id: "BLANK2", options: ["val", "right", "left", "parent"], answer: 2 }] , explanation: "node.val is the correct graph algorithm concept." },
          { difficulty: "average", q: "Level-order traversal is another name for:", options: ["DFS preorder", "DFS inorder", "DFS postorder", "BFS"], answer: 3 , explanation: "BFS is the correct answer for this concept." },
          { difficulty: "advanced", type: "freeform", q: "Write a function that returns the maximum depth of a binary tree using BFS (level-order traversal with a queue).", starterCode: "function maxDepthBFS(root) {\n  // your code here\n}", patterns: ["queue|\\[", "while.*length", "depth|level|count"], sampleAnswer: "function maxDepthBFS(root) {\n  if (!root) return 0;\n  const queue = [root];\n  let depth = 0;\n  while (queue.length) {\n    const size = queue.length;\n    for (let i = 0; i < size; i++) {\n      const node = queue.shift();\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    depth++;\n  }\n  return depth;\n}" },
          { difficulty: "advanced", type: "output", q: "What is the postorder traversal of this tree?", code: "// Tree:      1\n//           / \\\n//          2   3\n//         /   / \\\n//        4   5   6\n// Postorder visits: left, right, root", options: ["[1, 2, 4, 3, 5, 6]", "[4, 2, 5, 6, 3, 1]", "[4, 2, 1, 5, 3, 6]", "[1, 3, 6, 5, 2, 4]"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the steps to perform a BFS (level-order) traversal:", lines: ["Initialize a queue with the root node", "Dequeue the front node and process it", "Enqueue the node's left child if it exists", "Enqueue the node's right child if it exists", "Repeat until the queue is empty"], correctOrder: [0, 1, 2, 3, 4] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
    ]
  },
  {
    id: 7, title: "Sorting", icon: "\u{1F9EE}", color: "#E74C3C", desc: "Sorting Algorithms",
    lessons: [
      {
        title: "Bubble, Selection & Insertion Sort",
        slides: [
          { type: "teach", content: "**Bubble sort** repeatedly swaps adjacent elements if they're in the wrong order. Each pass 'bubbles' the largest unsorted element to its correct position.", highlight: "Bubble sort" },
          { type: "teach", content: "**Selection sort** finds the minimum in the unsorted part and places it at the front. **Insertion sort** builds a sorted portion one element at a time, inserting each into its correct spot.", highlight: "Selection sort" },
        ],
        questions: [
          { q: "Bubble sort works by repeatedly:", options: ["Dividing the array in half", "Swapping adjacent elements", "Finding the minimum", "Inserting into a sorted position"], answer: 1 , explanation: "Swapping adjacent elements is correct based on how this data structure or algorithm operates." },
          { q: "What is the time complexity of bubble sort in the worst case?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: 2 , explanation: "O(n^2) describes how the algorithm scales with input size." },
          { q: "Which sort builds a sorted portion by inserting one element at a time?", options: ["Bubble sort", "Selection sort", "Insertion sort", "Merge sort"], answer: 2 , explanation: "Insertion sort is correct based on how this data structure or algorithm operates." },
          { difficulty: "average", type: "output", q: "After ONE full pass of bubble sort, what does the array look like?", code: "let arr = [5, 3, 8, 1, 2];\n// Pass 1 of bubble sort:\n// Compare 5,3 → swap → [3,5,8,1,2]\n// Compare 5,8 → no swap\n// Compare 8,1 → swap → [3,5,1,8,2]\n// Compare 8,2 → swap → [3,5,1,2,8]\nconsole.log(arr);", options: ["[1, 2, 3, 5, 8]", "[3, 5, 1, 2, 8]", "[3, 1, 2, 5, 8]", "[5, 3, 8, 1, 2]"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the selection sort inner loop:", code: "function selectionSort(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    let minIdx = ___BLANK1___;\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[j] < arr[minIdx]) minIdx = ___BLANK2___;\n    }\n    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n  }\n}", blanks: [{ id: "BLANK1", options: ["0", "i", "j", "arr.length"], answer: 1 }, { id: "BLANK2", options: ["i", "j", "minIdx + 1", "0"], answer: 1 }] , explanation: "i is correct based on how this data structure or algorithm operates." },
          { difficulty: "average", q: "Which of these simple sorts performs best on nearly sorted data?", options: ["Bubble sort", "Selection sort", "Insertion sort", "They all perform the same"], answer: 2 , explanation: "Insertion sort is correct based on how this data structure or algorithm operates." },
          { difficulty: "advanced", type: "freeform", q: "Write an optimized bubble sort that stops early if no swaps occur during a pass.", starterCode: "function bubbleSort(arr) {\n  // your code here\n  return arr;\n}", patterns: ["swap|swapped|noSwap|didSwap", "break|return", "for|while"], sampleAnswer: "function bubbleSort(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    let swapped = false;\n    for (let j = 0; j < arr.length - 1 - i; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n        swapped = true;\n      }\n    }\n    if (!swapped) break;\n  }\n  return arr;\n}" },
          { difficulty: "advanced", type: "output", q: "How many comparisons does selection sort make on an array of 5 elements?", code: "// Selection sort comparisons:\n// Pass 1: compare indices 0 with 1,2,3,4 → 4 comparisons\n// Pass 2: compare indices 1 with 2,3,4   → 3 comparisons\n// Pass 3: compare indices 2 with 3,4     → 2 comparisons\n// Pass 4: compare indices 3 with 4       → 1 comparison\n// Total = ?", options: ["5", "10", "15", "20"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the steps of insertion sort for the element at index 3:", lines: ["Store the value at index 3 as key", "Compare key with element at index 2", "Shift elements right if they are greater than key", "Continue comparing leftward until key's position is found", "Insert key at the correct position"], correctOrder: [0, 1, 2, 3, 4] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "Merge Sort",
        slides: [
          { type: "teach", content: "**Merge sort** uses **divide and conquer**: split the array in half, recursively sort each half, then **merge** the sorted halves back together.", highlight: "Merge sort" },
          { type: "teach", content: "Merge sort always runs in **O(n log n)** time, but needs **O(n) extra space** for the temporary arrays during merging.", highlight: "O(n log n)" },
        ],
        questions: [
          { q: "Merge sort uses which algorithmic strategy?", options: ["Greedy", "Dynamic programming", "Divide and conquer", "Brute force"], answer: 2 , explanation: "Divide and conquer is correct based on how this data structure or algorithm operates." },
          { q: "What is the time complexity of merge sort?", options: ["O(n)", "O(n^2)", "O(n log n)", "O(log n)"], answer: 2 , explanation: "O(n log n) describes how the algorithm scales with input size." },
          { q: "The 'merge' step combines:", options: ["Two unsorted arrays into one", "Two sorted arrays into one sorted array", "Three arrays into two", "One array into two halves"], answer: 1 , explanation: "Two sorted arrays into one sorted array is the correct answer for this concept." },
          { difficulty: "average", type: "output", q: "What does the merge function return?", code: "function merge(left, right) {\n  const result = [];\n  let i = 0, j = 0;\n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) result.push(left[i++]);\n    else result.push(right[j++]);\n  }\n  return [...result, ...left.slice(i), ...right.slice(j)];\n}\nconsole.log(merge([1, 4, 6], [2, 3, 5]));", options: ["[1, 2, 3, 4, 5, 6]", "[2, 3, 5, 1, 4, 6]", "[1, 4, 6, 2, 3, 5]", "[6, 5, 4, 3, 2, 1]"], answer: 0 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the merge sort function:", code: "function mergeSort(arr) {\n  if (arr.length <= 1) return ___BLANK1___;\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.___BLANK2___(mid));\n  return merge(left, right);\n}", blanks: [{ id: "BLANK1", options: ["[]", "arr", "null", "0"], answer: 1 }, { id: "BLANK2", options: ["splice", "slice", "split", "filter"], answer: 1 }] , explanation: "arr is correct based on how this data structure or algorithm operates." },
          { difficulty: "average", q: "What is the space complexity of merge sort?", options: ["O(1)", "O(log n)", "O(n)", "O(n^2)"], answer: 2 , explanation: "O(n) describes how the algorithm scales with input size." },
          { difficulty: "advanced", type: "freeform", q: "Write a complete merge sort implementation including the merge helper function.", starterCode: "function mergeSort(arr) {\n  // your code here\n}\n\nfunction merge(left, right) {\n  // your code here\n}", patterns: ["merge\\(", "slice|splice", "left.*right|i.*j", "while|for"], sampleAnswer: "function mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let i = 0, j = 0;\n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) result.push(left[i++]);\n    else result.push(right[j++]);\n  }\n  return [...result, ...left.slice(i), ...right.slice(j)];\n}" },
          { difficulty: "advanced", type: "output", q: "How many levels of recursion does merge sort have for an array of 8 elements?", code: "// Level 0: [8 elements]\n// Level 1: [4 elements] [4 elements]\n// Level 2: [2] [2] [2] [2]\n// Level 3: [1] [1] [1] [1] [1] [1] [1] [1]\n// Levels = log2(8) = ?", options: ["2", "3", "4", "8"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the merge sort steps for the array [38, 27, 43, 3]:", lines: ["Split into [38, 27] and [43, 3]", "Split [38, 27] into [38] and [27]", "Split [43, 3] into [43] and [3]", "Merge [38] and [27] into [27, 38]", "Merge [43] and [3] into [3, 43]", "Merge [27, 38] and [3, 43] into [3, 27, 38, 43]"], correctOrder: [0, 1, 2, 3, 4, 5] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "Quicksort & Comparisons",
        slides: [
          { type: "teach", content: "**Quicksort** picks a **pivot** element, partitions the array so all smaller elements go left and larger go right, then recursively sorts each side.", highlight: "Quicksort" },
          { type: "teach", content: "Quicksort averages **O(n log n)** but degrades to **O(n^2)** with a bad pivot (e.g., always picking the smallest element). It sorts **in-place** using O(log n) stack space.", highlight: "O(n log n)" },
        ],
        questions: [
          { q: "In quicksort, the 'pivot' is used to:", options: ["Merge two halves", "Partition the array into smaller and larger sections", "Find the minimum element", "Count elements"], answer: 1 , explanation: "Partition the array into smaller and larger sections" },
          { q: "What is quicksort's average time complexity?", options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"], answer: 1 , explanation: "O(n log n) describes how the algorithm scales with input size." },
          { q: "Quicksort's worst case O(n^2) occurs when:", options: ["The array has even length", "The pivot always divides evenly", "The pivot is always the smallest or largest element", "The array contains duplicates"], answer: 2 , explanation: "The pivot is always the smallest or largest element" },
          { difficulty: "average", type: "output", q: "After one partition step with pivot = 5, what does the array look like?", code: "// Array: [3, 7, 8, 5, 2, 1, 9, 4]\n// Pivot: 5\n// Elements < 5 go left, >= 5 go right\n// Result after partition:", options: ["[3, 2, 1, 4, 5, 7, 8, 9]", "[1, 2, 3, 4, 5, 7, 8, 9]", "[5, 3, 7, 8, 2, 1, 9, 4]", "[9, 8, 7, 5, 4, 3, 2, 1]"], answer: 0 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the partition function:", code: "function partition(arr, low, high) {\n  const pivot = arr[high];\n  let i = ___BLANK1___;\n  for (let j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n      ___BLANK2___;\n    }\n  }\n  [arr[i], arr[high]] = [arr[high], arr[i]];\n  return i;\n}", blanks: [{ id: "BLANK1", options: ["0", "low", "high", "low - 1"], answer: 1 }, { id: "BLANK2", options: ["j++", "i++", "low++", "high--"], answer: 1 }] , explanation: "low is the correct answer for this concept." },
          { difficulty: "average", q: "Which sorting algorithm is generally fastest in practice for large random datasets?", options: ["Bubble sort", "Insertion sort", "Merge sort", "Quicksort"], answer: 3 , explanation: "Quicksort is correct based on how this data structure or algorithm operates." },
          { difficulty: "advanced", type: "freeform", q: "Write a quicksort implementation that uses the last element as pivot.", starterCode: "function quickSort(arr, low = 0, high = arr.length - 1) {\n  // your code here\n  return arr;\n}", patterns: ["partition|pivot", "quickSort.*low|quickSort.*high", "if.*low.*high|if.*high.*low"], sampleAnswer: "function quickSort(arr, low = 0, high = arr.length - 1) {\n  if (low < high) {\n    const pivot = partition(arr, low, high);\n    quickSort(arr, low, pivot - 1);\n    quickSort(arr, pivot + 1, high);\n  }\n  return arr;\n}\n\nfunction partition(arr, low, high) {\n  const pivot = arr[high];\n  let i = low;\n  for (let j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n      i++;\n    }\n  }\n  [arr[i], arr[high]] = [arr[high], arr[i]];\n  return i;\n}" },
          { difficulty: "advanced", type: "output", q: "Compare these three algorithms. Which row is CORRECT?", code: "//            | Best    | Average  | Worst   | Space  | Stable?\n// Merge Sort | O(nlogn)| O(nlogn) | O(nlogn)| O(n)   | Yes\n// Quicksort  | O(nlogn)| O(nlogn) | O(n^2)  | O(logn)| No\n// Insertion  | O(n)    | O(n^2)   | O(n^2)  | O(1)   | Yes", options: ["Only Merge Sort row is correct", "Only Quicksort row is correct", "All three rows are correct", "None are correct"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the sorting algorithms from slowest to fastest average-case performance:", lines: ["Bubble sort - O(n^2)", "Selection sort - O(n^2)", "Insertion sort - O(n^2)", "Merge sort - O(n log n)", "Quicksort - O(n log n)"], correctOrder: [0, 1, 2, 3, 4] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
    ]
  },
  {
    id: 8, title: "Searching", icon: "\u{1F9EE}", color: "#E74C3C", desc: "Search Algorithms",
    lessons: [
      {
        title: "Linear Search",
        slides: [
          { type: "teach", content: "**Linear search** checks every element one by one from start to end. It works on **any** array (sorted or unsorted) and runs in **O(n)** time.", highlight: "Linear search" },
          { type: "teach", content: "Linear search is simple but slow for large datasets. Its best case is **O(1)** (element found first) and worst case is **O(n)** (element at the end or not found).", highlight: "O(n)" },
        ],
        questions: [
          { q: "Linear search checks elements:", options: ["In random order", "From the middle outward", "One by one from start to end", "Only sorted elements"], answer: 2 , explanation: "One by one from start to end is the correct answer for this concept." },
          { q: "What is the worst-case time complexity of linear search?", options: ["O(1)", "O(log n)", "O(n)", "O(n^2)"], answer: 2 , explanation: "O(n) describes how the algorithm scales with input size." },
          { q: "Does linear search require the array to be sorted?", options: ["Yes, always", "No, it works on any array", "Only for numbers", "Only for strings"], answer: 1 , explanation: "No, it works on any array is correct based on how this data structure or algorithm operates." },
          { difficulty: "average", type: "output", q: "What does this function return?", code: "function linearSearch(arr, target) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) return i;\n  }\n  return -1;\n}\nconsole.log(linearSearch([10, 25, 30, 45, 50], 30));", options: ["-1", "30", "2", "3"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the linear search that returns all matching indices:", code: "function findAll(arr, target) {\n  const indices = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === ___BLANK1___) indices.___BLANK2___(i);\n  }\n  return indices;\n}", blanks: [{ id: "BLANK1", options: ["i", "target", "arr", "indices"], answer: 1 }, { id: "BLANK2", options: ["pop", "shift", "push", "splice"], answer: 2 }] , explanation: "target is the correct answer for this concept." },
          { difficulty: "average", q: "For an array of 1,000 elements, what is the average number of comparisons in linear search?", options: ["1", "10", "500", "1000"], answer: 2 , explanation: "500 is correct based on how this data structure or algorithm operates." },
          { difficulty: "advanced", type: "freeform", q: "Write a function that performs linear search on a 2D array (matrix) and returns the [row, col] position of the target, or [-1, -1] if not found.", starterCode: "function searchMatrix(matrix, target) {\n  // your code here\n}", patterns: ["for|while", "matrix\\[", "\\[.*row|\\[.*i", "return.*-1.*-1|return.*\\["], sampleAnswer: "function searchMatrix(matrix, target) {\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[i].length; j++) {\n      if (matrix[i][j] === target) return [i, j];\n    }\n  }\n  return [-1, -1];\n}" },
          { difficulty: "advanced", type: "output", q: "What is the output?", code: "function sentinelSearch(arr, target) {\n  const n = arr.length;\n  const last = arr[n - 1];\n  arr[n - 1] = target;\n  let i = 0;\n  while (arr[i] !== target) i++;\n  arr[n - 1] = last;\n  if (i < n - 1 || last === target) return i;\n  return -1;\n}\nconsole.log(sentinelSearch([4, 7, 2, 9, 1], 9));", options: ["2", "3", "4", "-1"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the search algorithms from least to most efficient for a SORTED array of 1 million elements:", lines: ["Linear search - O(n)", "Binary search - O(log n)", "Hash table lookup - O(1) average"], correctOrder: [0, 1, 2] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "Binary Search",
        slides: [
          { type: "teach", content: "**Binary search** works on **sorted arrays** by repeatedly comparing the target to the **middle element**. Each comparison eliminates half the remaining elements.", highlight: "Binary search" },
          { type: "teach", content: "Binary search runs in **O(log n)** time. For 1 billion elements, it needs at most ~30 comparisons! The key requirement: the array **must be sorted**.", highlight: "O(log n)" },
        ],
        questions: [
          { q: "Binary search requires the array to be:", options: ["Empty", "Sorted", "Of even length", "Containing unique elements"], answer: 1 , explanation: "Sorted is correct based on how this data structure or algorithm operates." },
          { q: "What is the time complexity of binary search?", options: ["O(n)", "O(n^2)", "O(log n)", "O(1)"], answer: 2 , explanation: "O(log n) describes how the algorithm scales with input size." },
          { q: "In binary search, if the target is less than the middle element, you search:", options: ["The right half", "The left half", "The entire array again", "The middle element again"], answer: 1 , explanation: "The left half follows from binary tree properties and traversal rules." },
          { difficulty: "average", type: "output", q: "What does this binary search return?", code: "function binarySearch(arr, target) {\n  let low = 0, high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) return mid;\n    else if (arr[mid] < target) low = mid + 1;\n    else high = mid - 1;\n  }\n  return -1;\n}\nconsole.log(binarySearch([2, 5, 8, 12, 16, 23, 38, 72], 23));", options: ["4", "5", "23", "-1"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the binary search:", code: "function binarySearch(arr, target) {\n  let low = 0, high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) return ___BLANK1___;\n    else if (arr[mid] < target) low = ___BLANK2___;\n    else high = mid - 1;\n  }\n  return -1;\n}", blanks: [{ id: "BLANK1", options: ["low", "high", "mid", "target"], answer: 2 }, { id: "BLANK2", options: ["mid", "mid + 1", "mid - 1", "low + 1"], answer: 1 }] , explanation: "mid follows from binary tree properties and traversal rules." },
          { difficulty: "average", q: "How many comparisons does binary search need for a sorted array of 1024 elements (worst case)?", options: ["10", "32", "512", "1024"], answer: 0 , explanation: "10 is correct based on how this data structure or algorithm operates." },
          { difficulty: "advanced", type: "freeform", q: "Write a recursive binary search function.", starterCode: "function binarySearchRecursive(arr, target, low = 0, high = arr.length - 1) {\n  // your code here\n}", patterns: ["binarySearchRecursive", "mid|middle", "return.*-1", "low.*high|high.*low"], sampleAnswer: "function binarySearchRecursive(arr, target, low = 0, high = arr.length - 1) {\n  if (low > high) return -1;\n  const mid = Math.floor((low + high) / 2);\n  if (arr[mid] === target) return mid;\n  if (arr[mid] < target) return binarySearchRecursive(arr, target, mid + 1, high);\n  return binarySearchRecursive(arr, target, low, mid - 1);\n}" },
          { difficulty: "advanced", type: "output", q: "What does this function return?", code: "function findFirstOccurrence(arr, target) {\n  let low = 0, high = arr.length - 1, result = -1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) {\n      result = mid;\n      high = mid - 1; // keep searching left\n    } else if (arr[mid] < target) low = mid + 1;\n    else high = mid - 1;\n  }\n  return result;\n}\nconsole.log(findFirstOccurrence([1, 3, 3, 3, 5, 7], 3));", options: ["1", "2", "3", "-1"], answer: 0 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Trace binary search for target=7 in [1, 3, 5, 7, 9, 11, 13]. Arrange the steps:", lines: ["low=0, high=6, mid=3, arr[3]=7", "Target equals arr[mid], return 3"], correctOrder: [0, 1] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "Search in Rotated Arrays",
        slides: [
          { type: "teach", content: "A **rotated sorted array** was originally sorted, then rotated at some pivot: `[4,5,6,7,0,1,2]`. Modified binary search can still find elements in **O(log n)**.", highlight: "rotated sorted array" },
          { type: "teach", content: "The key insight: in a rotated array, **at least one half is always sorted**. Determine which half is sorted, check if the target lies in that range, then narrow your search.", highlight: "one half is always sorted" },
        ],
        questions: [
          { q: "A rotated sorted array [4,5,6,1,2,3] was originally:", options: ["[4,5,6,1,2,3]", "[1,2,3,4,5,6]", "[6,5,4,3,2,1]", "[3,2,1,6,5,4]"], answer: 1 , explanation: "[1,2,3,4,5,6] is correct based on how this data structure or algorithm operates." },
          { q: "What is the time complexity of searching in a rotated sorted array using modified binary search?", options: ["O(n)", "O(n log n)", "O(log n)", "O(1)"], answer: 2 , explanation: "O(log n) describes how the algorithm scales with input size." },
          { q: "In a rotated sorted array, how many halves are guaranteed to be sorted?", options: ["None", "At least one", "Both", "Depends on rotation"], answer: 1 , explanation: "At least one is correct based on how this data structure or algorithm operates." },
          { difficulty: "average", type: "output", q: "What does this function return?", code: "function searchRotated(arr, target) {\n  let low = 0, high = arr.length - 1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[low] <= arr[mid]) {\n      if (target >= arr[low] && target < arr[mid]) high = mid - 1;\n      else low = mid + 1;\n    } else {\n      if (target > arr[mid] && target <= arr[high]) low = mid + 1;\n      else high = mid - 1;\n    }\n  }\n  return -1;\n}\nconsole.log(searchRotated([4, 5, 6, 7, 0, 1, 2], 0));", options: ["0", "3", "4", "-1"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the check for which half is sorted in a rotated array:", code: "if (arr[low] <= arr[___BLANK1___]) {\n  // Left half is sorted\n  if (target >= arr[low] && target < arr[mid]) {\n    ___BLANK2___ = mid - 1;\n  } else {\n    low = mid + 1;\n  }\n}", blanks: [{ id: "BLANK1", options: ["high", "mid", "low + 1", "0"], answer: 1 }, { id: "BLANK2", options: ["low", "high", "mid", "target"], answer: 1 }] , explanation: "mid is correct based on how this data structure or algorithm operates." },
          { difficulty: "average", q: "In [6,7,1,2,3,4,5], what is the rotation pivot index (the index of the smallest element)?", options: ["0", "1", "2", "5"], answer: 2 , explanation: "2 is the correct answer for this concept." },
          { difficulty: "advanced", type: "freeform", q: "Write a function to find the minimum element in a rotated sorted array using binary search.", starterCode: "function findMin(arr) {\n  // your code here\n}", patterns: ["low|left|lo", "high|right|hi", "mid|middle", "while"], sampleAnswer: "function findMin(arr) {\n  let low = 0, high = arr.length - 1;\n  while (low < high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] > arr[high]) low = mid + 1;\n    else high = mid;\n  }\n  return arr[low];\n}" },
          { difficulty: "advanced", type: "output", q: "What does findMin return?", code: "function findMin(arr) {\n  let low = 0, high = arr.length - 1;\n  while (low < high) {\n    const mid = Math.floor((low + high) / 2);\n    if (arr[mid] > arr[high]) low = mid + 1;\n    else high = mid;\n  }\n  return arr[low];\n}\nconsole.log(findMin([15, 18, 2, 3, 6, 12]));", options: ["15", "2", "18", "6"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Trace the modified binary search for target=1 in [4, 5, 6, 7, 0, 1, 2]:", lines: ["low=0, high=6, mid=3. arr[3]=7. Left half [4..7] is sorted. Target 1 not in [4,7], so low=4", "low=4, high=6, mid=5. arr[5]=1. Target found! Return 5"], correctOrder: [0, 1] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
    ]
  },
  {
    id: 9, title: "Recursion & Backtracking", icon: "\u{1F9EE}", color: "#E74C3C", desc: "Recursive Problem Solving",
    lessons: [
      {
        title: "Recursion Basics & Base Cases",
        slides: [
          { type: "teach", content: "**Recursion** is when a function calls itself. Every recursive function needs a **base case** (when to stop) and a **recursive case** (when to call itself with a smaller input).", highlight: "Recursion" },
          { type: "teach", content: "Without a base case, recursion runs forever and causes a **stack overflow**. Think of recursion like Russian nesting dolls: each doll opens to reveal a smaller one until you reach the smallest.", highlight: "base case" },
        ],
        questions: [
          { q: "Every recursive function must have:", options: ["A loop", "A base case", "Two parameters", "An array"], answer: 1 , explanation: "A base case is fundamental to how recursion and backtracking work." },
          { q: "What happens if a recursive function has no base case?", options: ["It returns 0", "It runs once", "Stack overflow / infinite recursion", "It returns undefined"], answer: 2 , explanation: "Stack overflow / infinite recursion is fundamental to how recursion and backtracking work." },
          { q: "In recursion, the 'recursive case' is when the function:", options: ["Stops", "Returns a value", "Calls itself with a smaller problem", "Throws an error"], answer: 2 , explanation: "Calls itself with a smaller problem is fundamental to how recursion and backtracking work." },
          { difficulty: "average", type: "output", q: "What does this function return?", code: "function factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\nconsole.log(factorial(5));", options: ["5", "15", "24", "120"], answer: 3 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the recursive sum function:", code: "function sum(n) {\n  if (n <= ___BLANK1___) return 0;\n  return n + sum(n - ___BLANK2___);\n}", blanks: [{ id: "BLANK1", options: ["1", "0", "-1", "n"], answer: 1 }, { id: "BLANK2", options: ["0", "1", "2", "n"], answer: 1 }] , explanation: "0 is fundamental to how recursion and backtracking work." },
          { difficulty: "average", q: "What is the base case in fibonacci(n) where fib(0)=0, fib(1)=1?", options: ["n > 1", "n === 0 or n === 1", "n < 0", "n === 2"], answer: 1 , explanation: "n === 0 or n === 1 is fundamental to how recursion and backtracking work." },
          { difficulty: "advanced", type: "freeform", q: "Write a recursive function that reverses a string.", starterCode: "function reverseString(str) {\n  // your code here\n}", patterns: ["reverseString|reverse", "str\\[0\\]|str\\.charAt|str\\.slice|str\\.substring", "return.*\\+|return.*concat"], sampleAnswer: "function reverseString(str) {\n  if (str.length <= 1) return str;\n  return reverseString(str.slice(1)) + str[0];\n}" },
          { difficulty: "advanced", type: "output", q: "How many times is fib() called for fib(5) using naive recursion?", code: "function fib(n) {\n  if (n <= 1) return n;\n  return fib(n - 1) + fib(n - 2);\n}\n// Count total function calls for fib(5):\n// fib(5) calls fib(4) + fib(3)\n// fib(4) calls fib(3) + fib(2)\n// ... and so on", options: ["5", "9", "15", "25"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the call stack frames for factorial(4) from first pushed to last pushed:", lines: ["factorial(4) pushed onto stack", "factorial(3) pushed onto stack", "factorial(2) pushed onto stack", "factorial(1) pushed onto stack - base case reached", "Stack frames pop and multiply: 1*2*3*4 = 24"], correctOrder: [0, 1, 2, 3, 4] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "Call Stack & Permutations",
        slides: [
          { type: "teach", content: "The **call stack** tracks every function call. Each recursive call adds a new **frame** to the stack. When the base case returns, frames **pop off** and compute results bottom-up.", highlight: "call stack" },
          { type: "teach", content: "**Permutations** are all possible orderings of a set. For [1,2,3], there are **3! = 6** permutations. Recursion generates them by fixing one element and permuting the rest.", highlight: "Permutations" },
        ],
        questions: [
          { q: "The call stack follows which principle?", options: ["First In, First Out (FIFO)", "Last In, First Out (LIFO)", "Random access", "Priority-based"], answer: 1 , explanation: "Last In, First Out (LIFO) reflects how this data structure operates." },
          { q: "How many permutations does [1, 2, 3] have?", options: ["3", "6", "9", "27"], answer: 1 , explanation: "6 is the correct answer for this concept." },
          { q: "When the base case is reached, the call stack:", options: ["Adds more frames", "Starts popping frames and returning values", "Resets to empty", "Throws an error"], answer: 1 , explanation: "Starts popping frames and returning values reflects how this data structure operates." },
          { difficulty: "average", type: "output", q: "What does this function print?", code: "function countdown(n) {\n  if (n === 0) { console.log('Done!'); return; }\n  console.log(n);\n  countdown(n - 1);\n}\ncountdown(3);", options: ["3 2 1 Done!", "Done! 1 2 3", "3 2 1", "1 2 3 Done!"], answer: 0 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the permutation generator:", code: "function permutations(arr) {\n  if (arr.length <= 1) return [___BLANK1___];\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    const rest = arr.filter((_, idx) => idx !== ___BLANK2___);\n    const perms = permutations(rest);\n    perms.forEach(p => result.push([arr[i], ...p]));\n  }\n  return result;\n}", blanks: [{ id: "BLANK1", options: ["arr", "[]", "arr[0]", "null"], answer: 0 }, { id: "BLANK2", options: ["0", "i", "arr.length", "arr[i]"], answer: 1 }] , explanation: "arr is the correct answer for this concept." },
          { difficulty: "average", q: "What is the maximum call stack depth for factorial(100)?", options: ["1", "10", "100", "10000"], answer: 2 , explanation: "100 reflects how this data structure operates." },
          { difficulty: "advanced", type: "freeform", q: "Write a function that generates all permutations of a string and returns them as an array.", starterCode: "function stringPermutations(str) {\n  // your code here\n}", patterns: ["permutation|perm", "for|forEach", "push|concat|\\.\\.\\.", "length.*[<=>].*[01]|===.*''"], sampleAnswer: "function stringPermutations(str) {\n  if (str.length <= 1) return [str];\n  const result = [];\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    const remaining = str.slice(0, i) + str.slice(i + 1);\n    const perms = stringPermutations(remaining);\n    perms.forEach(p => result.push(char + p));\n  }\n  return result;\n}" },
          { difficulty: "advanced", type: "output", q: "What does this tail-recursive-style function return?", code: "function sumTail(n, acc = 0) {\n  if (n <= 0) return acc;\n  return sumTail(n - 1, acc + n);\n}\nconsole.log(sumTail(4));", options: ["4", "6", "10", "24"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the call stack trace for sumTail(3, 0):", lines: ["sumTail(3, 0) - acc = 0 + 3 = 3", "sumTail(2, 3) - acc = 3 + 2 = 5", "sumTail(1, 5) - acc = 5 + 1 = 6", "sumTail(0, 6) - base case, return 6"], correctOrder: [0, 1, 2, 3] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "Backtracking & N-Queens",
        slides: [
          { type: "teach", content: "**Backtracking** explores all possible solutions by making choices, and **undoing** (backtracking) choices that lead to dead ends. Think of it as navigating a maze and retracing your steps.", highlight: "Backtracking" },
          { type: "teach", content: "The **N-Queens problem** asks: place N queens on an NxN chessboard so no two queens threaten each other. Backtracking tries placing queens row by row, undoing invalid placements.", highlight: "N-Queens" },
        ],
        questions: [
          { q: "Backtracking is best described as:", options: ["Always finding the optimal solution first", "Trying all possibilities and undoing bad choices", "Sorting before searching", "Using hash maps"], answer: 1 , explanation: "Trying all possibilities and undoing bad choices is fundamental to how recursion and backtracking work." },
          { q: "In the N-Queens problem, queens cannot share the same:", options: ["Color", "Row, column, or diagonal", "Size", "Row only"], answer: 1 , explanation: "Row, column, or diagonal is the correct answer for this concept." },
          { q: "When backtracking finds an invalid state, it:", options: ["Crashes", "Starts over from scratch", "Undoes the last choice and tries the next option", "Returns the invalid answer"], answer: 2 , explanation: "Undoes the last choice and tries the next option is fundamental to how recursion and backtracking work." },
          { difficulty: "average", type: "output", q: "How many solutions does the 4-Queens problem have?", code: "// 4-Queens: place 4 queens on a 4x4 board\n// Solution 1: [1, 3, 0, 2] (queen positions per row)\n// Solution 2: [2, 0, 3, 1]\n// Total solutions = ?", options: ["0", "1", "2", "4"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the safety check for N-Queens:", code: "function isSafe(board, row, col) {\n  for (let i = 0; i < row; i++) {\n    if (board[i] === ___BLANK1___) return false;\n    if (Math.abs(board[i] - col) === Math.abs(i - ___BLANK2___)) return false;\n  }\n  return true;\n}", blanks: [{ id: "BLANK1", options: ["row", "col", "i", "board[row]"], answer: 1 }, { id: "BLANK2", options: ["col", "row", "0", "board[i]"], answer: 1 }] , explanation: "col is the correct answer for this concept." },
          { difficulty: "average", q: "The time complexity of the N-Queens backtracking solution is approximately:", options: ["O(n)", "O(n^2)", "O(n!)", "O(2^n)"], answer: 2 , explanation: "O(n!) describes how the algorithm scales with input size." },
          { difficulty: "advanced", type: "freeform", q: "Write a backtracking function that finds all solutions to the N-Queens problem. Return an array of solutions where each solution is an array of column positions.", starterCode: "function solveNQueens(n) {\n  const solutions = [];\n  // your code here\n  return solutions;\n}", patterns: ["isSafe|isValid|canPlace", "backtrack|solve|place", "push.*slice|push.*\\[\\.\\.\\.", "pop|splice|board\\[row\\].*="], sampleAnswer: "function solveNQueens(n) {\n  const solutions = [];\n  function backtrack(board, row) {\n    if (row === n) { solutions.push([...board]); return; }\n    for (let col = 0; col < n; col++) {\n      if (isSafe(board, row, col)) {\n        board.push(col);\n        backtrack(board, row + 1);\n        board.pop();\n      }\n    }\n  }\n  backtrack([], 0);\n  return solutions;\n}" },
          { difficulty: "advanced", type: "output", q: "What does this backtracking subset generator produce for [1, 2]?", code: "function subsets(nums) {\n  const result = [];\n  function backtrack(start, current) {\n    result.push([...current]);\n    for (let i = start; i < nums.length; i++) {\n      current.push(nums[i]);\n      backtrack(i + 1, current);\n      current.pop();\n    }\n  }\n  backtrack(0, []);\n  return result;\n}\nconsole.log(subsets([1, 2]));", options: ["[[1], [2]]", "[[1, 2]]", "[[], [1], [2], [1, 2]]", "[[1], [1, 2], [2]]"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the backtracking algorithm steps for N-Queens:", lines: ["Start with an empty board, row = 0", "Try placing a queen in each column of the current row", "Check if placement is safe (no conflicts)", "If safe, place queen and move to the next row", "If all columns fail, backtrack (remove last queen, try next column)", "If all rows are filled, record the solution"], correctOrder: [0, 1, 2, 3, 4, 5] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
    ]
  },
  {
    id: 10, title: "Dynamic Programming", icon: "\u{1F9EE}", color: "#E74C3C", desc: "DP & Optimization",
    lessons: [
      {
        title: "Memoization",
        slides: [
          { type: "teach", content: "**Memoization** is a top-down DP technique: solve problems recursively but **cache** results of subproblems to avoid redundant computation.", highlight: "Memoization" },
          { type: "teach", content: "Naive recursive Fibonacci is **O(2^n)** because it recomputes the same values. With memoization, it drops to **O(n)** because each subproblem is solved only once.", highlight: "O(n)" },
        ],
        questions: [
          { q: "Memoization improves performance by:", options: ["Using more memory to sort faster", "Caching results to avoid re-computation", "Running code in parallel", "Reducing array size"], answer: 1 , explanation: "Caching results to avoid re-computation is a key dynamic programming concept." },
          { q: "Memoization is a ___ approach to dynamic programming.", options: ["Bottom-up", "Top-down", "Left-right", "Random"], answer: 1 , explanation: "Top-down is a key dynamic programming concept." },
          { q: "Without memoization, naive recursive Fibonacci has complexity:", options: ["O(n)", "O(n^2)", "O(2^n)", "O(log n)"], answer: 2 , explanation: "O(2^n) describes how the algorithm scales with input size." },
          { difficulty: "average", type: "output", q: "What does this memoized function return?", code: "function fib(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);\n  return memo[n];\n}\nconsole.log(fib(7));", options: ["7", "8", "13", "21"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the memoization wrapper:", code: "function memoize(fn) {\n  const cache = {};\n  return function(n) {\n    if (n in ___BLANK1___) return cache[n];\n    cache[n] = ___BLANK2___(n);\n    return cache[n];\n  };\n}", blanks: [{ id: "BLANK1", options: ["fn", "cache", "n", "this"], answer: 1 }, { id: "BLANK2", options: ["cache", "memoize", "fn", "n"], answer: 2 }] , explanation: "cache is a key dynamic programming concept." },
          { difficulty: "average", q: "With memoization, how many times is fib(3) computed when calculating fib(6)?", options: ["1", "3", "5", "8"], answer: 0 , explanation: "1 is a key dynamic programming concept." },
          { difficulty: "advanced", type: "freeform", q: "Write a memoized function that computes the number of unique paths in an m x n grid, where you can only move right or down.", starterCode: "function uniquePaths(m, n, memo = {}) {\n  // your code here\n}", patterns: ["memo|cache", "uniquePaths.*m.*n|uniquePaths.*m-1|uniquePaths.*n-1", "return.*1|===.*1", "\\+"], sampleAnswer: "function uniquePaths(m, n, memo = {}) {\n  const key = `${m},${n}`;\n  if (key in memo) return memo[key];\n  if (m === 1 || n === 1) return 1;\n  memo[key] = uniquePaths(m - 1, n, memo) + uniquePaths(m, n - 1, memo);\n  return memo[key];\n}" },
          { difficulty: "advanced", type: "output", q: "How many function calls does memoized fib(5) make vs naive fib(5)?", code: "// Naive fib(5):     15 total calls\n// Memoized fib(5):  9 total calls\n// Savings = ?", options: ["3 calls saved", "6 calls saved", "10 calls saved", "No difference"], answer: 1 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the steps of solving a problem with memoization:", lines: ["Identify the recursive structure and subproblems", "Write a naive recursive solution", "Add a cache/memo object as parameter", "Before computing, check if result is in cache", "After computing, store the result in cache", "Return cached result on subsequent calls"], correctOrder: [0, 1, 2, 3, 4, 5] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "Tabulation",
        slides: [
          { type: "teach", content: "**Tabulation** is a bottom-up DP technique: build a **table** (array) of solutions starting from the smallest subproblems up to the final answer. No recursion needed!", highlight: "Tabulation" },
          { type: "teach", content: "Tabulation avoids the overhead of recursive call stacks. You fill in a table iteratively, where each cell depends on previously computed cells.", highlight: "bottom-up" },
        ],
        questions: [
          { q: "Tabulation solves problems in which direction?", options: ["Top-down", "Bottom-up", "Right to left", "Random order"], answer: 1 , explanation: "Bottom-up is a key dynamic programming concept." },
          { q: "Tabulation uses which data structure to store results?", options: ["Stack", "Queue", "Table/array", "Linked list"], answer: 2 , explanation: "Table/array is a key dynamic programming concept." },
          { q: "Compared to memoization, tabulation avoids:", options: ["Storing intermediate results", "Using arrays", "Recursive call stack overhead", "All computation"], answer: 2 , explanation: "Recursive call stack overhead is a key dynamic programming concept." },
          { difficulty: "average", type: "output", q: "What does this tabulated Fibonacci return?", code: "function fibTab(n) {\n  if (n <= 1) return n;\n  const dp = [0, 1];\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[n];\n}\nconsole.log(fibTab(8));", options: ["8", "13", "21", "34"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the tabulated staircase problem (ways to climb n stairs, 1 or 2 steps at a time):", code: "function climbStairs(n) {\n  const dp = [1, 1];\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[___BLANK1___];\n  }\n  return dp[___BLANK2___];\n}", blanks: [{ id: "BLANK1", options: ["i", "i - 2", "i + 1", "0"], answer: 1 }, { id: "BLANK2", options: ["0", "1", "n", "n - 1"], answer: 2 }] , explanation: "i - 2 is a key dynamic programming concept." },
          { difficulty: "average", q: "The space complexity of standard tabulated Fibonacci is:", options: ["O(1)", "O(log n)", "O(n)", "O(n^2)"], answer: 2 , explanation: "O(n) describes how the algorithm scales with input size." },
          { difficulty: "advanced", type: "freeform", q: "Write a space-optimized tabulated Fibonacci that uses only O(1) space (only two variables instead of an array).", starterCode: "function fibOptimized(n) {\n  // your code here\n}", patterns: ["prev|a|first", "curr|b|second", "for|while", "return"], sampleAnswer: "function fibOptimized(n) {\n  if (n <= 1) return n;\n  let prev = 0, curr = 1;\n  for (let i = 2; i <= n; i++) {\n    const next = prev + curr;\n    prev = curr;\n    curr = next;\n  }\n  return curr;\n}" },
          { difficulty: "advanced", type: "output", q: "What does this coin change tabulation return?", code: "function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin <= i && dp[i - coin] + 1 < dp[i]) {\n        dp[i] = dp[i - coin] + 1;\n      }\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}\nconsole.log(coinChange([1, 5, 10, 25], 30));", options: ["2", "3", "6", "30"], answer: 0 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the steps to solve the coin change problem using tabulation:", lines: ["Create dp array of size amount+1, fill with Infinity", "Set dp[0] = 0 (0 coins needed for amount 0)", "For each amount from 1 to target, try each coin", "If coin <= current amount, check if dp[amount - coin] + 1 is fewer coins", "Update dp[amount] with the minimum coins needed", "Return dp[target] (or -1 if Infinity)"], correctOrder: [0, 1, 2, 3, 4, 5] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
      {
        title: "Classic DP Patterns",
        slides: [
          { type: "teach", content: "Classic DP problems follow patterns: **Fibonacci-like** (climbing stairs, house robber), **knapsack** (subset sum, bounded choices), and **string DP** (longest common subsequence, edit distance).", highlight: "patterns" },
          { type: "teach", content: "The **0/1 Knapsack** problem: given items with weights and values, maximize value without exceeding the weight capacity. Each item is either taken or left (0 or 1).", highlight: "0/1 Knapsack" },
        ],
        questions: [
          { q: "In the 0/1 Knapsack problem, each item can be:", options: ["Used unlimited times", "Split into fractions", "Either taken or left entirely", "Sorted by weight"], answer: 2 , explanation: "Either taken or left entirely is a key dynamic programming concept." },
          { q: "The 'climbing stairs' problem is similar to which sequence?", options: ["Prime numbers", "Fibonacci", "Powers of 2", "Factorials"], answer: 1 , explanation: "Fibonacci is the correct answer for this concept." },
          { q: "Dynamic programming is useful when a problem has:", options: ["No patterns", "Overlapping subproblems and optimal substructure", "Only one solution", "Random outputs"], answer: 1 , explanation: "Overlapping subproblems and optimal substructure is a key dynamic programming concept." },
          { difficulty: "average", type: "output", q: "What does this house robber function return?", code: "function rob(houses) {\n  if (houses.length === 0) return 0;\n  if (houses.length === 1) return houses[0];\n  const dp = [houses[0], Math.max(houses[0], houses[1])];\n  for (let i = 2; i < houses.length; i++) {\n    dp[i] = Math.max(dp[i - 1], dp[i - 2] + houses[i]);\n  }\n  return dp[houses.length - 1];\n}\nconsole.log(rob([2, 7, 9, 3, 1]));", options: ["10", "11", "12", "14"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "average", type: "fill", q: "Complete the 0/1 knapsack recurrence:", code: "// dp[i][w] = max value using items 0..i with capacity w\nif (weights[i] > w) {\n  dp[i][w] = dp[___BLANK1___][w]; // can't take item i\n} else {\n  dp[i][w] = Math.max(\n    dp[i - 1][w],              // skip item i\n    dp[i - 1][w - weights[i]] + ___BLANK2___  // take item i\n  );\n}", blanks: [{ id: "BLANK1", options: ["i", "i - 1", "i + 1", "0"], answer: 1 }, { id: "BLANK2", options: ["weights[i]", "values[i]", "dp[i]", "w"], answer: 1 }] , explanation: "i - 1 is a key dynamic programming concept." },
          { difficulty: "average", q: "The longest common subsequence of 'ABCDE' and 'ACE' is:", options: ["'AE' (length 2)", "'ACE' (length 3)", "'ABCDE' (length 5)", "'ABC' (length 3)"], answer: 1 , explanation: "'ACE' (length 3) is the correct answer for this concept." },
          { difficulty: "advanced", type: "freeform", q: "Write a function that solves the 0/1 knapsack problem using tabulation. Given arrays of weights and values, and a capacity, return the maximum value.", starterCode: "function knapsack(weights, values, capacity) {\n  // your code here\n}", patterns: ["dp|table", "for.*for|nested", "Math\\.max", "weights\\[|values\\["], sampleAnswer: "function knapsack(weights, values, capacity) {\n  const n = values.length;\n  const dp = Array.from({length: n + 1}, () => new Array(capacity + 1).fill(0));\n  for (let i = 1; i <= n; i++) {\n    for (let w = 0; w <= capacity; w++) {\n      if (weights[i - 1] <= w) {\n        dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);\n      } else {\n        dp[i][w] = dp[i - 1][w];\n      }\n    }\n  }\n  return dp[n][capacity];\n}" },
          { difficulty: "advanced", type: "output", q: "What does this LCS function return?", code: "function lcs(a, b) {\n  const dp = Array.from({length: a.length + 1},\n    () => new Array(b.length + 1).fill(0));\n  for (let i = 1; i <= a.length; i++) {\n    for (let j = 1; j <= b.length; j++) {\n      if (a[i-1] === b[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\n      else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n    }\n  }\n  return dp[a.length][b.length];\n}\nconsole.log(lcs('AGGTAB', 'GXTXAYB'));", options: ["2", "3", "4", "5"], answer: 2 , explanation: "The code produces this result when executed step by step following the language rules." },
          { difficulty: "advanced", type: "order", q: "Arrange the steps to solve a DP problem:", lines: ["Identify if the problem has overlapping subproblems", "Define the state (what dp[i] or dp[i][j] represents)", "Write the recurrence relation (how states relate)", "Define base cases (dp[0], dp[0][0], etc.)", "Choose top-down (memoization) or bottom-up (tabulation)", "Implement and optionally optimize space"], correctOrder: [0, 1, 2, 3, 4, 5] , explanation: "Each step logically depends on the previous one, forming the correct sequence." },
        ]
      },
    ]
  },
];
